# es6-markdown
一.环境

新建 package.json文件： npm init -y

配置babel转码规则：npm install --save-dev babel-preset-latest（具体规则自选）

安装全局babel命令行转码：npm install --global babel-cli

安装babel命令行转码：npm install --save-dev babel-cli

配置babel的‘build’命令： 在package.json的‘script’中配置----"build": "babel src -d lib"  （这个命令目的是把src文件夹下的文件都转译，转译后的文件放到lib目录下）

新建.babelrc文件：  type nul>.babelrc, 里面配置{ "presets": ["latest"（前面配置的转码规则）],"plugins": []}

新建src文件夹，把代码文件放进去。写完后，跑 npm run build。会自动生成lib文件夹，里面有跟src里js对应的编译好的js文件

babel-node：提供一个支持es6的repl环境可以直接运行es6脚本，babel-register：改写require命令为其加钩子只对require命令加载的文件转码且是实时转码只适合开发环境使用，babel-core：需要调用Babel 的API 进行转码时使用，babel-polyfill:用于转换es6新增的api。待看。

二.let do const
1.let
let只在其所在的代码块有效，适用于for循环，for循环中的let i只在本轮循环有效，每次循环都是一个新i，且设置循环变量的部分是父作用域，循环体内部是单独的子作用域；不允许在相同作用域内，重复声明同一个变量；只在本块级作用域内可用，内外层作用域里的同名变量互不影响；变量名不提升，存在暂时性死区，只能在声明的位置后使用该变量；允许在块级作用域中声明函数，但应避免这样做，因为与es5差异太大，如非要写，得写成函数表达式 let f=function(){}不要写成函数声明语句function f(){}；

2.do
块级作用域要想有返回值，除了设置全局变量，还可以用do表达式,即在括号外加do，如： let a = do{let b=f(); b+1;}, a的值即为块级作用域内部b的最终计算值；

3.const
用于声明只读常量，声明后值不可改变，声明时必须赋值。不允许在相同作用域内，重复声明同一个变量；只在本块级作用域内可用，内外层作用域里的同名变量互不影响；变量名不提升，存在暂时性死区，只能在声明的位置后使用该变量；
本质:const保证的不是变量的值不可改动，而是变量指向的内存地址不可改动；简单类型的数据值就保存在指向的内存地址，因此等同于常量；符合类型数据(对象数组等)变量保存的只是一个指针，const确保指针固定，但指向的内存地址的数据结构仍可改变，不被控制。如 const f={}; f.prop = 123; console.log(f.prop)得到123。如需将对象冻结为不可变更数据结构，可用const a = Object.freeze({})方法。

声明变量的六种方法：var(变量=顶层对象属性) function(变量=顶层对象属性) let(变量!=顶层对象属性) const(变量!=顶层对象属性) class import

顶层对象：
浏览器指window对象，node指global对象，
