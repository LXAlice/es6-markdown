# es6-markdown
一.环境

新建 package.json文件： npm init -y

配置babel转码规则：npm install --save-dev babel-preset-latest（具体规则自选）

安装全局babel命令行转码：npm install --global babel-cli

安装babel命令行转码：npm install --save-dev babel-cli

配置babel的‘build’命令： 在package.json的‘script’中配置----"build": "babel src -d lib"  （这个命令目的是把src文件夹下的文件都转译，转译后的文件放到lib目录下）

新建.babelrc文件：  type nul>.babelrc, 里面配置{ "presets": ["latest"（前面配置的转码规则）],"plugins": []}

新建src文件夹，把代码文件放进去。写完后，跑 npm run build。会自动生成lib文件夹，里面有跟src里js对应的编译好的js文件

babel-node：提供一个支持es6的repl环境可以直接运行es6脚本，babel-register：改写require命令为其加钩子只对require命令加载的文件转码且是实时转码只适合开发环境使用，babel-core：需要调用Babel 的API 进行转码时使用，babel-polyfill:用于转换es6新增的api。待看。

二.let do const

1.let
let只在其所在的代码块有效，适用于for循环，for循环中的let i只在本轮循环有效，每次循环都是一个新i，且设置循环变量的部分是父作用域，循环体内部是单独的子作用域；不允许在相同作用域内，重复声明同一个变量；只在本块级作用域内可用，内外层作用域里的同名变量互不影响；变量名不提升，存在暂时性死区，只能在声明的位置后使用该变量；允许在块级作用域中声明函数，但应避免这样做，因为与es5差异太大，如非要写，得写成函数表达式 let f=function(){}不要写成函数声明语句function f(){}；

2.do
块级作用域要想有返回值，除了设置全局变量，还可以用do表达式,即在括号外加do，如： let a = do{let b=f(); b+1;}, a的值即为块级作用域内部b的最终计算值；

3.const
用于声明只读常量，声明后值不可改变，声明时必须赋值。不允许在相同作用域内，重复声明同一个变量；只在本块级作用域内可用，内外层作用域里的同名变量互不影响；变量名不提升，存在暂时性死区，只能在声明的位置后使用该变量；
本质:const保证的不是变量的值不可改动，而是变量指向的内存地址不可改动；简单类型的数据值就保存在指向的内存地址，因此等同于常量；符合类型数据(对象数组等)变量保存的只是一个指针，const确保指针固定，但指向的内存地址的数据结构仍可改变，不被控制。如 const f={}; f.prop = 123; console.log(f.prop)得到123。如需将对象冻结为不可变更数据结构，可用const a = Object.freeze({})方法。

声明变量的六种方法：var(变量=顶层对象属性) function(变量=顶层对象属性) let(变量!=顶层对象属性) const(变量!=顶层对象属性) class import

顶层对象：
浏览器指window对象，node指global对象，

三.解构赋值

1.数组
“模式匹配”原则：等号两边结构位置相同，左边变量就被赋予右边对应的值。let [x,y,..z]=['a']即x='a',y=undifined,z=[] 。
设置默认值： let [x='a']=[],es6内部使用严格相等运算符（===），当等号右边的值===undefined时左边设置的默认值生效。默认值表达式是惰性求值：let [a=f()]=[]，此时执行f()；[a=f()]=['d']，此时不执行f()。默认值可引用其他变量，但得在变量声明后使用，如[x=1,y=x]=[2]即x=2,y=2；[x=y,y]=[]报错，y在做x的默认值时还没声明。

2.对象
等号两边变量名相同才可将右边变量的值赋给左边相同名字的变量。与具体位置无关。左边变量名可写重复多次匹配右边的值{a,a:b}={a:'123'}即a='123',b='123'。实际是先找到等号两边的同名属性，再把右边属性的属性值赋给左边属性的属性值变量名。{a}={a:'123'}等同于{a:a}={a:'123'},即a='123'。如变量名不一致，写成：{a:b}={a:'abc'}即b='abc'。
设置默认值：let {a:b=1}={a:2}即b=2,es6内部使用严格相等运算符（===），当等号右边的值===undefined时左边设置的默认值生效。
let x; {x}={}报错，{x}会被认为是一个代码块，不能把大括号写在行首。 let x;({x}={})不会报错。

3.数组的对象处理方式
数组是特殊的对象，可通过下标获得等号右边的数组对应下标的值。let arr = [1,2,3];  let {0:a}=arr; 即 a=1。不可直接写成 let {0}=arr 。

4.字符串
等号右边是字符串可被看做数组，如 let [a,b]='hello';即a='h',b='e'。同时字符串有属性如length，也可对属性操作取值，如：let {length:a}='hello';即 a=5 。

5.数值和布尔值
等号右边是数值或布尔值会被先转为对象，可获取对象的属性赋值。如：let {toString:a}=123;

6.undifined和null
等号右边是undifined或null会直接报错，不会被转换成对象。

7.函数传参
形参可使用解构赋值对应得到实参。function f([a,b]){}; f([1,2]);即a=1,b=2；
设置默认值：function f({a=0,b=0}){}; f({a:3});结构含义为{a=0,b=0}={a:3}即a=3,b=0。 function f({a,b}={a:0,b;0}){}; f({a:1});结构含义为{a,b}={a:1} 即a=1,b=undefined;
注意：函数形参本身即可设置默认值，function f([a]=[a:1])意思为形参[a]整体有默认值[a:1]，若此时执行f()不传参，a=1；与前面function f([a=1]){}给模式的每个变量赋默认值不是一个概念。

8.圆括号
用例：let a;({a}={a:5});即a=5。
以下情况会导致解构歧义，不可使用：
变量声明语句的模式部分(即等号左边部分)，如 let {(c)}={} ；赋值语句的模式部分，如 let {(a)}={a:1} ；函数形参，如function f([a,(b)]){}；
以下可使用情况：赋值语句的非模式部分，但尽量还是不要用。

四.字符串操作扩展（unicode编号>0xFFFF即为32位字符）

1.unicode表示法：\u{码点}===四字节的utf-16编码。

2.codePointAt()方法：
js内部用utf-16格式存字符，默认字符为2个字节，4个字节的字符依然被认为是2个字节charAt()和charCodeAt()无法对多字节字符做正确处理。codePointAt()方法可以返回字符串里对应位置的（任意字节数的32位的utf-16字符的十进制码点）。处理两个字节的字符的码点时，codePointAt()===charCodeAt()。如果想要转换成16进制的码点，则用toString(16)转换即可，如a.codePointAt(0).toString(16)，即取字符串a中第一个字符的16进制码点。但是，此时直接处理，并不能过滤掉非32位的字符的占位，如a="b c";要想转换c就需要写成a.codePointAt(3),若要直接过滤掉非32位字符，要用for...of循环，此循环在执行时会直接忽略非32位utf-16字符。

3.String.fromCodePoint()
将码点返回成对应字符。可识别32位的utf-16字符。如括号里有多个参数，则会被合并成一个字符串返回（别瞎用）。
String.fromCharCode()不可识别32位的utf-16字符。

4.for...of循环
此遍历器可识别大于0xFFFF的码点对应的字符，会把字符处理成一个整体，不会把一个字符按码点拆开。普通for循环处理字符会把32位的字符拆成两块，无法处理成一个整体。

5.at()
charAt()方法返回字符串给定位置的字符，但不能识别码点大于0xFFFF的字符，会把其拆开。at()方法可以识别。此方法需要使用对应的垫片库才可使用。

6.normalize()
unicode正规化：用于将字符的各种不同的表示方法统一为同样的形式，不能识别>2字符的合成，可选参数来指定返回的字符形式。如'\u01D1'.normalize() === '\u004F\u030C'.normalize()

7.includes()、startsWith()、endsWith()
includes('word',6)：返回布尔值，表示是否找到了参数字符串;参数：字符串，开始查找的位置。
startsWith('word',6)：返回布尔值，表示参数字符串是否在原字符串的头部;参数：字符串，开始查找的位置。
endsWith('word',6)：返回布尔值，表示参数字符串是否在原字符串的尾部;参数：字符串，从头开始查找的字符串的长度。

8.repeat()、padStart()、padEnd()
repeat(3)：返回新字符串，表示将原字符串重复n次；参数：>-1的数，会取整。<=-1会报错。如：'a'.repeat(0);即""。
padStart(6,'padword')：返回指定长度的新字符串，在头部用指定字符串补全。原字符串>=指定长度时，返回原值。用于补全的指定字符串会根据长度需要被重复或截取。参数省略指定字符串时，默认使用空格补全长度。如：'a'.padStart(4,'12345');即得'123a'。
padEnd(6,'padword')：返回指定长度的新字符串，在尾部用指定字符串补全。用法同padStart。

9.模板字符串
反引号中使用，保留所有空格、回车等格式，可在${}中嵌入变量、js运算、调用函数，特殊字符可用\反斜杠转义。后面加.trim()可去掉最前面和最后面的换行和空格。
标签模板功能：
紧跟在一个函数名后面使用反引号模板，该函数将被调用来处理这个模板字符串。如：alert`123`等同于alert('123')。
当模板内有变量时，模板内参数会被处理成两部分：①以${}位置为划分，组成一个每项为字符串的数组，并有raw属性保存转义后的原字符串；②变量被先转换成字符串参数，与数组同级，传入函数。如：let a=5,b=10; f`Hello ${ a + b } world ${ a * b }`;等同于f(['Hello ', ' world ', ''], 15, 50)。！！！注意：${}前后无论是否有字符串都会被划分成数组的一项，也就是说，字符串数组的长度=变量的数量+1。
传入函数后，arguments的第一项就是字符串数组并有raw属性保存转义后的原字符串，第二项开始是变量值。
标签模板功能应用场景：过滤掉如<>&等html特殊字符串防止用户恶意内容，多语言转换，使用标签模板嵌入其他编程语言。
String.raw()：
是一个模板字符串的标签函数，可以把所有变量替换并对\开头的特殊字符转义，返回给定模板字符串转义后的原始字面量值。
模板字符串的限制：其他编程语言在js中当做unicode转义不成功会报错，但可利用标签模板在函数中通过raw属性输出原字符串。

五.正则的扩展

1.RegExp构造函数
用法：① new RegExp('字符串','flag修饰符')；② new RegExp(/表达式/flag,'flag修饰符')；此时逗号后面的flag会将表达式里写的flag全部替换掉，如 new RegExp(/[a-z]/gi,'g').flags值是g而不是gi。

2.字符串的正则方法
字符串对象有四个方法可用正则：replace()、split()、search()、match()；
RegExp把这四个方法全都定义到了RegExp对象上。使用方法如下：表达式/RegExp实例[Symbol.replace/split/search/match]('字符串')。如：/ab/[Symbol.match]('abc-mno-xyz')等价于'abc-mno-xyz'.match(/ab/) 。

3.修饰符-u
做flags使用u：正则会把一个由四个字节组成的utf-16字符正确看做一个整体，而不是看做两块。此时，/^.$/u.test(四字节的字符)会返回true 。并且支持在表达式内部使用四字节的字符，被{}量词、\S等正确识别，/𠮷{1}/u.test('𠮷')会返回true 。也可识别编码不同但字形相近的非规范字符。
同时在表达式内部使用\u{}：可表示unicode字符  /\u{unicode字符}/u 。

4.unicode属性类\p和\P
用于匹配符合/不包括Unicode 某种属性的所有字符。
/\p{unicode某属性名=某属性值(值可选)}/u。如，/^\p{Decimal_Number}+$/u;即匹配所有十进制字符，/^\p{Number}+$/u匹配所有数字。

5.‘粘连’flags修饰符-y
与g类似，全局匹配。但y需要确保每次进行匹配的第一个字符都符合表达式（类似是^的全局功能）。如/a/g.test('-a')返回true，但/a/y.test('-a')返回false。因为‘-a’进行匹配的第一个字符是‘-’不是表达式的‘a’。
在string的match方法中，必须与g一起用才可返回所有匹配，否则只返回第一个匹配，如'a1a2'.match(/a\d/y) 返回["a1"]，'a1a2'.match(/a\d/gy) 返回["a1", "a2"]。
应用场景：用于确保字符串无误，如确保‘3+4’没有字符遗漏或非法字符。
sticky属性：判断是否设置了y修饰符，/a/y.sticky返回true 。

6.新增属性：
/表达式/.source：返回//中的内容。
/表达式/.flags：返回//后的修饰符。

7.flags修饰符dotAll-s
//中的.表示除行终止符外所有单个字符。如//后用上s，则//中的.则可匹配所有单字符，因此称为dotAll(点代表所有)修饰符。如/./s.test('\n')返回true。

8.先行断言&后行断言
先行断言：/a(?=b)/.exec('acab')返回第二个a，/a(?!b)/.exec('acab')返回第一个a。
后行断言：/(?<=b)a/.exec('caba')返回第二个a，/(?<!b)a/.exec('caba')返回第一个a。
后行断言()里的表达式会从右向左依模块顺序读取模块，因此引用\1要写在子模块()的左侧，如/(?<!(b)cd\1)/,读到\1时还未读取到(b)因此报错，应写成/(?<!\1cd(b))/此时先读取到(b)然后读到cd然后读到\1。在正常表达式中，连续两个贪婪模式时，最左边的最贪婪，后行断言是从右向左读取因此最右边的最贪婪。如'abcd'.match(/([a-z]+)([a-z]+)$/)值为['abcd','abc','d']；而'abcd'.match(/(?<=([a-z]+)([a-z]+))$/)值为['','a','bcd']

9.具名组匹配
即给每个存储的()指定名字。使用方法：(?<名字name>正常表达式)，通过exec的值的groups.name属性获取对应匹配结果。如： const byn=/(?<a>[a-z])(?<b>[0-9])/.exec('q5'); byn.groups.a 可取值‘q’；byn.groups.b 可取值‘5’。
replace方法：replace第二个参数里用'$<名字name>'即可获取具名组对应的值，如：'q5'.replace(/(?<a>[a-z])(?<b>[0-9])/,'$<a>-$<b>')即可获得结果'q-5'。replace第二个参数也可是函数，此函数形参按顺序如下：整个匹配结果，第一个组匹配，第二个组匹配，...,第n个组匹配，匹配在原字符串中开始的位置，原字符串，groups，如：'q5'.replace(/(?<a>[a-z])(?<b>[0-9])/,function(){arguments[arguments.length-1]即可获得groups，处理后return出结果即可})。
表达式内部引用具名组：\k<组名>即可引用完全相同的具名组并生成相同的对应的匹配值。效果等同于引用类\1。







