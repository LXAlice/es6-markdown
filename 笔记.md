# es6-markdown
一.环境

新建 package.json文件： npm init -y

配置babel转码规则：npm install --save-dev babel-preset-latest（具体规则自选）

安装全局babel命令行转码：npm install --global babel-cli

安装babel命令行转码：npm install --save-dev babel-cli

配置babel的‘build’命令： 在package.json的‘script’中配置----"build": "babel src -d lib"  （这个命令目的是把src文件夹下的文件都转译，转译后的文件放到lib目录下）

新建.babelrc文件：  type nul>.babelrc, 里面配置{ "presets": ["latest"（前面配置的转码规则）],"plugins": []}

新建src文件夹，把代码文件放进去。写完后，跑 npm run build。会自动生成lib文件夹，里面有跟src里js对应的编译好的js文件

babel-node：提供一个支持es6的repl环境可以直接运行es6脚本，babel-register：改写require命令为其加钩子只对require命令加载的文件转码且是实时转码只适合开发环境使用，babel-core：需要调用Babel 的API 进行转码时使用，babel-polyfill:用于转换es6新增的api。待看。

二.let do const

1.let
let只在其所在的代码块有效，适用于for循环，for循环中的let i只在本轮循环有效，每次循环都是一个新i，且设置循环变量的部分是父作用域，循环体内部是单独的子作用域；不允许在相同作用域内，重复声明同一个变量；只在本块级作用域内可用，内外层作用域里的同名变量互不影响；变量名不提升，存在暂时性死区，只能在声明的位置后使用该变量；允许在块级作用域中声明函数，但应避免这样做，因为与es5差异太大，如非要写，得写成函数表达式 let f=function(){}不要写成函数声明语句function f(){}；

2.do
块级作用域要想有返回值，除了设置全局变量，还可以用do表达式,即在括号外加do，如： let a = do{let b=f(); b+1;}, a的值即为块级作用域内部b的最终计算值；

3.const
用于声明只读常量，声明后值不可改变，声明时必须赋值。不允许在相同作用域内，重复声明同一个变量；只在本块级作用域内可用，内外层作用域里的同名变量互不影响；变量名不提升，存在暂时性死区，只能在声明的位置后使用该变量；
本质:const保证的不是变量的值不可改动，而是变量指向的内存地址不可改动；简单类型的数据值就保存在指向的内存地址，因此等同于常量；符合类型数据(对象数组等)变量保存的只是一个指针，const确保指针固定，但指向的内存地址的数据结构仍可改变，不被控制。如 const f={}; f.prop = 123; console.log(f.prop)得到123。如需将对象冻结为不可变更数据结构，可用const a = Object.freeze({})方法。

声明变量的六种方法：var(变量=顶层对象属性) function(变量=顶层对象属性) let(变量!=顶层对象属性) const(变量!=顶层对象属性) class import

顶层对象：
浏览器指window对象，node指global对象，

三.解构赋值

1.数组
“模式匹配”原则：等号两边结构位置相同，左边变量就被赋予右边对应的值。let [x,y,..z]=['a']即x='a',y=undifined,z=[] 。
设置默认值： let [x='a']=[],es6内部使用严格相等运算符（===），当等号右边的值===undefined时左边设置的默认值生效。默认值表达式是惰性求值：let [a=f()]=[]，此时执行f()；[a=f()]=['d']，此时不执行f()。默认值可引用其他变量，但得在变量声明后使用，如[x=1,y=x]=[2]即x=2,y=2；[x=y,y]=[]报错，y在做x的默认值时还没声明。

2.对象
等号两边变量名相同才可将右边变量的值赋给左边相同名字的变量。与具体位置无关。左边变量名可写重复多次匹配右边的值{a,a:b}={a:'123'}即a='123',b='123'。实际是先找到等号两边的同名属性，再把右边属性的属性值赋给左边属性的属性值变量名。{a}={a:'123'}等同于{a:a}={a:'123'},即a='123'。如变量名不一致，写成：{a:b}={a:'abc'}即b='abc'。
设置默认值：let {a:b=1}={a:2}即b=2,es6内部使用严格相等运算符（===），当等号右边的值===undefined时左边设置的默认值生效。
let x; {x}={}报错，{x}会被认为是一个代码块，不能把大括号写在行首。 let x;({x}={})不会报错。

3.数组的对象处理方式
数组是特殊的对象，可通过下标获得等号右边的数组对应下标的值。let arr = [1,2,3];  let {0:a}=arr; 即 a=1。不可直接写成 let {0}=arr 。

4.字符串
等号右边是字符串可被看做数组，如 let [a,b]='hello';即a='h',b='e'。同时字符串有属性如length，也可对属性操作取值，如：let {length:a}='hello';即 a=5 。

5.数值和布尔值
等号右边是数值或布尔值会被先转为对象，可获取对象的属性赋值。如：let {toString:a}=123;

6.undifined和null
等号右边是undifined或null会直接报错，不会被转换成对象。

7.函数传参
形参可使用解构赋值对应得到实参。function f([a,b]){}; f([1,2]);即a=1,b=2；
设置默认值：function f({a=0,b=0}){}; f({a:3});结构含义为{a=0,b=0}={a:3}即a=3,b=0。 function f({a,b}={a:0,b;0}){}; f({a:1});结构含义为{a,b}={a:1} 即a=1,b=undefined;
注意：函数形参本身即可设置默认值，function f([a]=[a:1])意思为形参[a]整体有默认值[a:1]，若此时执行f()不传参，a=1；与前面function f([a=1]){}给模式的每个变量赋默认值不是一个概念。

8.圆括号
用例：let a;({a}={a:5});即a=5。
以下情况会导致解构歧义，不可使用：
变量声明语句的模式部分(即等号左边部分)，如 let {(c)}={} ；赋值语句的模式部分，如 let {(a)}={a:1} ；函数形参，如function f([a,(b)]){}；
以下可使用情况：赋值语句的非模式部分，但尽量还是不要用。










