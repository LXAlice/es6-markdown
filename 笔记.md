# es6-markdown
一.环境

新建 package.json文件： npm init -y

配置babel转码规则：npm install --save-dev babel-preset-latest（具体规则自选）

安装全局babel命令行转码：npm install --global babel-cli

安装babel命令行转码：npm install --save-dev babel-cli

配置babel的‘build’命令： 在package.json的‘script’中配置----"build": "babel src -d lib"  （这个命令目的是把src文件夹下的文件都转译，转译后的文件放到lib目录下）

新建.babelrc文件：  type nul>.babelrc, 里面配置{ "presets": ["latest"（前面配置的转码规则）],"plugins": []}

新建src文件夹，把代码文件放进去。写完后，跑 npm run build。会自动生成lib文件夹，里面有跟src里js对应的编译好的js文件

babel-node：提供一个支持es6的repl环境可以直接运行es6脚本，babel-register：改写require命令为其加钩子只对require命令加载的文件转码且是实时转码只适合开发环境使用，babel-core：需要调用Babel 的API 进行转码时使用，babel-polyfill:用于转换es6新增的api。待看。

二.let do const

1.let
let只在其所在的代码块有效，适用于for循环，for循环中的let i只在本轮循环有效，每次循环都是一个新i，且设置循环变量的部分是父作用域，循环体内部是单独的子作用域；不允许在相同作用域内，重复声明同一个变量；只在本块级作用域内可用，内外层作用域里的同名变量互不影响；变量名不提升，存在暂时性死区，只能在声明的位置后使用该变量；允许在块级作用域中声明函数，但应避免这样做，因为与es5差异太大，如非要写，得写成函数表达式 let f=function(){}不要写成函数声明语句function f(){}；

2.do
块级作用域要想有返回值，除了设置全局变量，还可以用do表达式,即在括号外加do，如： let a = do{let b=f(); b+1;}, a的值即为块级作用域内部b的最终计算值；

3.const
用于声明只读常量，声明后值不可改变，声明时必须赋值。不允许在相同作用域内，重复声明同一个变量；只在本块级作用域内可用，内外层作用域里的同名变量互不影响；变量名不提升，存在暂时性死区，只能在声明的位置后使用该变量；
本质:const保证的不是变量的值不可改动，而是变量指向的内存地址不可改动；简单类型的数据值就保存在指向的内存地址，因此等同于常量；符合类型数据(对象数组等)变量保存的只是一个指针，const确保指针固定，但指向的内存地址的数据结构仍可改变，不被控制。如 const f={}; f.prop = 123; console.log(f.prop)得到123。如需将对象冻结为不可变更数据结构，可用const a = Object.freeze({})方法。

声明变量的六种方法：var(变量=顶层对象属性) function(变量=顶层对象属性) let(变量!=顶层对象属性) const(变量!=顶层对象属性) class import

顶层对象：
浏览器指window对象，node指global对象，

三.解构赋值

1.数组
“模式匹配”原则：等号两边结构位置相同，左边变量就被赋予右边对应的值。let [x,y,..z]=['a']即x='a',y=undifined,z=[] 。
设置默认值： let [x='a']=[],es6内部使用严格相等运算符（===），当等号右边的值===undefined时左边设置的默认值生效。默认值表达式是惰性求值：let [a=f()]=[]，此时执行f()；[a=f()]=['d']，此时不执行f()。默认值可引用其他变量，但得在变量声明后使用，如[x=1,y=x]=[2]即x=2,y=2；[x=y,y]=[]报错，y在做x的默认值时还没声明。

2.对象
等号两边变量名相同才可将右边变量的值赋给左边相同名字的变量。与具体位置无关。左边变量名可写重复多次匹配右边的值{a,a:b}={a:'123'}即a='123',b='123'。实际是先找到等号两边的同名属性，再把右边属性的属性值赋给左边属性的属性值变量名。{a}={a:'123'}等同于{a:a}={a:'123'},即a='123'。如变量名不一致，写成：{a:b}={a:'abc'}即b='abc'。
设置默认值：let {a:b=1}={a:2}即b=2,es6内部使用严格相等运算符（===），当等号右边的值===undefined时左边设置的默认值生效。
let x; {x}={}报错，{x}会被认为是一个代码块，不能把大括号写在行首。 let x;({x}={})不会报错。

3.数组的对象处理方式
数组是特殊的对象，可通过下标获得等号右边的数组对应下标的值。let arr = [1,2,3];  let {0:a}=arr; 即 a=1。不可直接写成 let {0}=arr 。

4.字符串
等号右边是字符串可被看做数组，如 let [a,b]='hello';即a='h',b='e'。同时字符串有属性如length，也可对属性操作取值，如：let {length:a}='hello';即 a=5 。

5.数值和布尔值
等号右边是数值或布尔值会被先转为对象，可获取对象的属性赋值。如：let {toString:a}=123;

6.undifined和null
等号右边是undifined或null会直接报错，不会被转换成对象。

7.函数传参
形参可使用解构赋值对应得到实参。function f([a,b]){}; f([1,2]);即a=1,b=2；
设置默认值：function f({a=0,b=0}){}; f({a:3});结构含义为{a=0,b=0}={a:3}即a=3,b=0。 function f({a,b}={a:0,b;0}){}; f({a:1});结构含义为{a,b}={a:1} 即a=1,b=undefined;
注意：函数形参本身即可设置默认值，function f([a]=[a:1])意思为形参[a]整体有默认值[a:1]，若此时执行f()不传参，a=1；与前面function f([a=1]){}给模式的每个变量赋默认值不是一个概念。

8.圆括号
用例：let a;({a}={a:5});即a=5。
以下情况会导致解构歧义，不可使用：
变量声明语句的模式部分(即等号左边部分)，如 let {(c)}={} ；赋值语句的模式部分，如 let {(a)}={a:1} ；函数形参，如function f([a,(b)]){}；
以下可使用情况：赋值语句的非模式部分，但尽量还是不要用。

四.字符串操作扩展（unicode编号>0xFFFF即为32位字符）

1.unicode表示法：\u{码点}===四字节的utf-16编码。

2.codePointAt()方法：
js内部用utf-16格式存字符，默认字符为2个字节，4个字节的字符依然被认为是2个字节charAt()和charCodeAt()无法对多字节字符做正确处理。codePointAt()方法可以返回字符串里对应位置的（任意字节数的32位的utf-16字符的十进制码点）。处理两个字节的字符的码点时，codePointAt()===charCodeAt()。如果想要转换成16进制的码点，则用toString(16)转换即可，如a.codePointAt(0).toString(16)，即取字符串a中第一个字符的16进制码点。但是，此时直接处理，并不能过滤掉非32位的字符的占位，如a="b c";要想转换c就需要写成a.codePointAt(3),若要直接过滤掉非32位字符，要用for...of循环，此循环在执行时会直接忽略非32位utf-16字符。

3.String.fromCodePoint()
将码点返回成对应字符。可识别32位的utf-16字符。如括号里有多个参数，则会被合并成一个字符串返回（别瞎用）。
String.fromCharCode()不可识别32位的utf-16字符。

4.for...of循环
此遍历器可识别大于0xFFFF的码点对应的字符，会把字符处理成一个整体，不会把一个字符按码点拆开。普通for循环处理字符会把32位的字符拆成两块，无法处理成一个整体。

5.at()
charAt()方法返回字符串给定位置的字符，但不能识别码点大于0xFFFF的字符，会把其拆开。at()方法可以识别。此方法需要使用对应的垫片库才可使用。

6.normalize()
unicode正规化：用于将字符的各种不同的表示方法统一为同样的形式，不能识别>2字符的合成，可选参数来指定返回的字符形式。如'\u01D1'.normalize() === '\u004F\u030C'.normalize()

7.includes()、startsWith()、endsWith()
includes('word',6)：返回布尔值，表示是否找到了参数字符串;参数：字符串，开始查找的位置。
startsWith('word',6)：返回布尔值，表示参数字符串是否在原字符串的头部;参数：字符串，开始查找的位置。
endsWith('word',6)：返回布尔值，表示参数字符串是否在原字符串的尾部;参数：字符串，从头开始查找的字符串的长度。

8.repeat()、padStart()、padEnd()
repeat(3)：返回新字符串，表示将原字符串重复n次；参数：>-1的数，会取整。<=-1会报错。如：'a'.repeat(0);即""。
padStart(6,'padword')：返回指定长度的新字符串，在头部用指定字符串补全。原字符串>=指定长度时，返回原值。用于补全的指定字符串会根据长度需要被重复或截取。参数省略指定字符串时，默认使用空格补全长度。如：'a'.padStart(4,'12345');即得'123a'。
padEnd(6,'padword')：返回指定长度的新字符串，在尾部用指定字符串补全。用法同padStart。

9.模板字符串
反引号中使用，保留所有空格、回车等格式，可在${}中嵌入变量、js运算、调用函数，特殊字符可用\反斜杠转义。后面加.trim()可去掉最前面和最后面的换行和空格。
标签模板功能：
紧跟在一个函数名后面使用反引号模板，该函数将被调用来处理这个模板字符串。如：alert`123`等同于alert('123')。
当模板内有变量时，模板内参数会被处理成两部分：①以${}位置为划分，组成一个每项为字符串的数组，并有raw属性保存转义后的原字符串；②变量被先转换成字符串参数，与数组同级，传入函数。如：let a=5,b=10; f`Hello ${ a + b } world ${ a * b }`;等同于f(['Hello ', ' world ', ''], 15, 50)。！！！注意：${}前后无论是否有字符串都会被划分成数组的一项，也就是说，字符串数组的长度=变量的数量+1。
传入函数后，arguments的第一项就是字符串数组并有raw属性保存转义后的原字符串，第二项开始是变量值。
标签模板功能应用场景：过滤掉如<>&等html特殊字符串防止用户恶意内容，多语言转换，使用标签模板嵌入其他编程语言。
String.raw()：
是一个模板字符串的标签函数，可以把所有变量替换并对\开头的特殊字符转义，返回给定模板字符串转义后的原始字面量值。
模板字符串的限制：其他编程语言在js中当做unicode转义不成功会报错，但可利用标签模板在函数中通过raw属性输出原字符串。







